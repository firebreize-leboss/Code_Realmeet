Ajouter un syst√®me d'√©coute en temps r√©el des annulations d'activit√©s pour notifier l'utilisateur imm√©diatement, que l'app soit en foreground ou en background.

1. Cr√©er le fichier hooks/useActivityCancellationListener.ts :
- √âcouter via Supabase Realtime les UPDATE sur la table "activities" o√π le status change vers "paused" ou "ended" (pas "cancelled" qui n'existe pas dans le schema)
- √âcouter aussi les DELETE sur "activities"
- Quand un changement est d√©tect√©, v√©rifier si l'utilisateur courant (via useAuth) est inscrit √† cette activit√© en cherchant dans slot_participants jointure avec activity_slots.activity_id correspondant. ATTENTION : slot_participants n'a PAS de champ "status", la simple pr√©sence d'une row confirme la participation, donc pas de filtre .eq('status', 'confirmed')
- Si l'app est en foreground (AppState === 'active') ‚Üí afficher un Alert.alert avec le nom de l'activit√© (champ "nom") et un bouton "Voir d√©tails" qui navigue vers /activity-detail?id=...
- Si l'app est en background ‚Üí envoyer une notification locale imm√©diate via Notifications.scheduleNotificationAsync avec trigger: null, title "üòî Activit√© annul√©e", body avec le nom, et data { type: 'activity', activityId: ... }
- Cleanup les channels Supabase et AppState listener dans le return du useEffect
- Le hook d√©pend de user?.id

2. Dans app/(tabs)/_layout.tsx (PAS app/_layout.tsx car useAuth n√©cessite d'√™tre dans AuthProvider, comme c'est d√©j√† le cas pour useCancellationCheck) :
- Importer et appeler useActivityCancellationListener() apr√®s les autres hooks existants

3. Dans lib/notifications.ts, dans la m√©thode initialize(), modifier le receivedListener pour ignorer les push de type 'activity_cancelled' (√©viter le doublon avec le Realtime) :
- Si notification.request.content.data?.type === 'activity_cancelled', faire un return sans traitement
- Garder le console.log pour les autres types